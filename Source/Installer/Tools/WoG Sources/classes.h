
struct HMonstr_{
  char   *Header;      // заголовок диалога
  char   *MName;       // название монстра
  char   *MInfo;       // хар-ки монстра
  char   *Comment;     // коментарий к происходящему
  long   MonNum;       // номер монстра по порядку
  long   Attack;       // атака монстра
  long   Defence;      // защита
  long   Shots;        // количество выстрелов (если 0-не писать)
  long   DamageLo;     // Мин. урон
  long   DamageHi;     // Мах. урон  - объед. с пред в одну строку через тире
  long   HitPoints;    // здоровье
  long   Param1;       // пока не используем
  long   Speed;        // скорость
  long   ResNeed[7];   // количество соответствующего ресурса
  long   ResOwn[7];    // количество ресурсов у игрока
  long   MAvailable;   // доступно монстров для найма
  long   MHired;       // нанятых монстров (устанавливается)
};

//=================================================

struct _Diplomacy{
 int GamerAvailable[8]; // по 8-ми игрокам 1-есть, 0-нет такого (в порядке следования цветов)
 long GamerIndex;        // номер игрока
 char GamerEnable[8][2]; // 0-данному О нельзя посылать, 1-можно
 char GamerSent[8][2];   // 0, если данному О ничего не посылалось и 1, если посылалось
 // Второй индекс значит 0-новое послание, 1-ответ на присланное.
 // GamerEnable[8][2] и GamerSent[8][2] связаны так. Если GamerEnable[i][j]
 // ноль, то кнопочка "послать" должна быть зашадена, т.к. в этот день уже
 // посылалось, а если не ноль, то разрешена. Ты же должен установить
 // единички в GamerSent[i][j], если это посылалось. Я потом просто копирую все
 // единички из  GamerSent[i][j] в нолики в GamerEnable[8][2].
 long DipLevel[8][8];    // матрица 8 на 8, где ячейка [i][j]
                         // хронит процент ненависти (0-100) i к j (отношение j к i может быть другим)
                         // в этом массиве хранится измененное И отношение ко всем О
 long ShowLevels[7];     // уровень отношений, не выше которого  показывается данный ресурс О (0-100) - работает для всех
 long Resources[8][7];   // ресурсы всех
 long ResSent[7][8][8];     // отосланные ресурсы по всем О (i/j/k, i - количество ресурса, j- от игрока, k - к игроку)
 long ResvMessage[8][8]; // принятые и не прочит. сообщения (инд.,-1-нет)
 long ReplMessage[8][8]; // сообщения в ответ (индекс ответа, -1-нет)
 long SentMessage[8][8]; // новое сообщения (индекс сообщ., -1-нет)
 char ***Messages;        // все сообщения и ответы (см. ниже)
};

//=================================================
/*
struct _Sphinx{
char* Text1;    // Текст №1 сообщения / вопроса
char* Pic1Path; // путь до первой картинки - если NULL, то не показывается
char* Pic2Path; // путь до второй картинки - если NULL, то не показывается
char* Pic3Path; // путь до третьей картинки - если NULL, то не показывается
char* Pic4Path; // путь до четвертой картинки - если NULL, то не показывается
char* Pic1Hint; // пояснение к картинке №1
char* Pic2Hint; // пояснение к картинке №2
char* Pic3Hint; // пояснение к картинке №3
char* Pic4Hint; // пояснение к картинке №4
char* Text2;    // Текст №2 сообщения / вопроса
char* Text3;    // Текст №3 сообщения / вопроса
char* Text4;    // Текст ответа (возвращается)
long SelItm;    // Номер выбранного итема 1-4 (возвращается)
char* Chk1Text; // Текст для кнопки №1 - если NULL, то не показывается
char* Chk2Text; // Текст для кнопки №2 - если NULL, то не показывается
char* Chk3Text; // Текст для кнопки №3 - если NULL, то не показывается
char* Chk4Text; // Текст для кнопки №4 - если NULL, то не показывается
};
*/
//=================================================

struct _Sphinx1{
char* Text1;    // Текст №1 сообщения/вопроса
char* Text2;    // Текст №2 сообщения/вопроса
char* Text3;    // Текст №3 сообщения/вопроса
char* Text4;    // Текст ответа (возвращается)
long SelItm;    // Номер выбранного итема 1-4 (возвращается)
char* Pic1Path; // путь до первой картинки - если NULL, то не показывается
char* Pic2Path; // путь до второй картинки - если NULL, то не показывается
char* Pic3Path; // путь до третьей картинки - если NULL, то не показывается
char* Pic4Path; // путь до четвертой картинки - если NULL, то не показывается
char* Pic1Hint; // пояснение к картинке №1
char* Pic2Hint; // пояснение к картинке №2
char* Pic3Hint; // пояснение к картинке №3
char* Pic4Hint; // пояснение к картинке №4
char* Chk1Text; // Текст для кнопки №1 - если NULL, то не показывается
char* Chk2Text; // Текст для кнопки №2 - если NULL, то не показывается
char* Chk3Text; // Текст для кнопки №3 - если NULL, то не показывается
char* Chk4Text; // Текст для кнопки №4 - если NULL, то не показывается
char* Chk1Hint; // пояснение к кнопке №1
char* Chk2Hint; // пояснение к кнопке №2
char* Chk3Hint; // пояснение к кнопке №3
char* Chk4Hint; // пояснение к кнопке №4
char ShowCancel;// показавать/непоказавать кнопку Cancel
};

//=================================================

struct _CurseShow{
char **Pics;   // 10 указателей на картинки (0-конец)
char **Text1;  // текст снизу при выборе картинки (1-я строка) (0-конец)
char **Text2;  // текст снизу при выборе картинки (2-я строка) (0-конец)
};

//=================================================

struct _Intro{
char *AVIBMPPath; // ресурс
char Cicling;     // показ зациклен (для bmp неважен)
};

//=================================================

struct _CheckBoxes{
char *Caption;     // текст Заголовка диалога
int   Number;      // кол-во галочек
char **Text;       // указатель на строки (0-больше нет)
int *State;        // состояние галочек - количество, как и Text
                   // 0 - не поставлена
                   // 1 - поставлена
                   // 2 - не поставлена, не меняется
                   // 3 - поставлена, не меняется
char OnlyOne;      // true - RadioButtons
                   // false - CheckBoxes

};

//=================================================

struct _DlgNPC{
int Flags;     // флаги - см. ниже
/*
  Flags & 0x00000001 - ; НПС живой, иначе мертвый
                         Если он мертвый, то кнопка уволить напрещена и надпись "МЕРТВ"
                         написана.
  Flags & 0x00000002 - ; можно редактировать имя НПС
                         остальное позже обсудим
  Flags & 0x00000004 - ; нельзя передавать артифакты от/к герою.
                         остальное позже обсудим
  Flags & 0x00000008 - ; показат кнопку увольнения

  Функция возвращает номер выбранной картинки (0...6), если Request=1
и что угодно (например,0), если Request=0
*/
int DlgLeft;    // Кородинаты окна по горизонтали
int DlgTop;     // Координаты окна по вертекали
char *Name;     // Имя NPC. Это буфер на 32 символа. Последний 0, так
                // что при редактировании имя может быть не длиннее 31.
                // указвтель НЕ МЕНЯТЬ - изменение прямо копировать по
                // указателю в мой буфер
char *Portrait; // Портрет NPC
char *PortraitHint; // текст хинта для портрета
char *HeroName; // имя героя-хозяина
int   Level;    // уровень НПС
int   pAT,hAT;  // атака и атака с учетом атаки героя
                // (выводится следом в скобках)
int   pDF,hDF;  // защита и с учетом героя
int   pHP;      // здоровье
int   pSP;      // скорость
int   pDML,pDMH;// урон нижний и верхний через черточку
int   pMP;      // магическая сила
int   pMR;      //магическая защита с символом % на конце
int   pShots;   // количество выстрелов. если 0, то это пустая строка
char *Description; // описание
char *SpecIcon1; // иконка заклинания
char *SpecText1; // текст рядом (в две или три коротких строки)
char *SpecHint1; // хинт для первой иконки и для текста рядом
char *SpecPopUpText1; // ТЕКСТ ДЛЯ ПОПАП ОКНА
char *SpecIcon2; // иконка другого бонуса
char *SpecText2; // текст рядом (в две или три коротких строки)
char *SpecHint2; // хинт для второй иконки и для текста рядом
char *SpecPopUpText2; // ТЕКСТ ДЛЯ ПОПАП ОКНА
int   CurExp;    // текущий опыт
int   NextExp;   // след. опыт
char *Type;      // тип NPC
char *TypePopUpText; // ТЕКСТ ДЛЯ ПОПАП ОКНА
char *TypeHint; // ТЕКСТ ДЛЯ ХИНТА
char *Bonus[6]; // 6 путей к первым 6 картинкам 70 на 70
char *BonusHints[6]; // 6 хинтов для первых 6 картинок
char *BonusPopUpText[6]; // 6 текстов для первых 6 картинок
char *SpecBonus[6]; // 6 путей ко вторым 6 картинкам как сейчас
char *SpecBonusHints[6]; // 6 хинтов для вторых 6 картинок
char *SpecBonusPopUpText[6]; // 6 текстов для вторых 6 картинок
//char *Information;      // Информация
int   Request;   // если 1, то игрок должен выбрать картинку внизу
char *Next[6];   // 6 путей к нижним 6 картинкам 70 на 70 из которых
                 // игрок должен выбрать одну и нажать Ок
char *NextActive[6];
char *NextHints[6]; // 6 хинтов к нижним 6 картинкам
char *NextPopUpTexts[6]; // 6 текстов к нижним 6 картинкам
char *ArtIcons[6]; // иконка артифакта ("NONE" - пустой)
char *ArtHints[6]; // хинт для иконки артифакта
char *ArtPopUpTexts[6]; // текст для попап окна
char ArtOutput[6]; // артифакт отдается - 1, оставляется - 0
};

//=================================================

struct _PopUpRadioButtons{
char *Caption;     // текст Заголовка диалога
int   Number;      // кол-во позиций для выбора
char **Text;       // указатель на строки (0-больше нет)
int SelIndex;      // номер выбранной позиции
int DlgLeft;       // Кородинаты окна по горизонтали
int DlgTop;        // Координаты окна по вертекали
};

//=================================================

struct DlgSetup_ItemList{
  char  *Name;        // название группы
  char  *Hint;        // текст хинта внизу (при наведении на имя группы)
  char  *PopUp;       // текст в окне по правой мыши (при клике на имя группы)
  int   *ItemState;   // ук. на массив состояния галочек
  char **ItemName;    // текст справа от галочки
  char **ItemHint;    // текст хинта внизу (одна строка)
  char **ItemPopUp;   // текст в окне по правой мыши.
  int    Type;        // 0-нет группы, 1-чекбоксы, 2-радиобутоны
  int    ItemCount;   // число элементов
};

struct DlgSetup_Page{
  char *Name; // заголовок страницы
  char *Hint; // текст хинта внизу (одна строка)
  char *PopUp; // текст в окне по правой мыши
  DlgSetup_ItemList *ItemListLT; // левая верхняя
  DlgSetup_ItemList *ItemListLB; // левая нижняя
  DlgSetup_ItemList *ItemListRT; // правая верхняя
  DlgSetup_ItemList *ItemListRB; // правая нижняя
  char Enabled;                  // страница вкл/выкл
};

struct _DlgSetup{
  char *Name;                // название окна
  char *Hint;                // текст хинта внизу (при наведении на имя окна)
  char *PopUp;               // текст в окне по правой мыши (при клике на имя окна)
  char *Intro;               // текст вступления
  DlgSetup_Page *Pages[8];   // страницы
  int   (*Listener)(int Type,int Page, int ItemList,int Item);
  // ук. на функцию, которую надо вызывать при каждом изменении
  // Type - 0 - кнопки, 1 - элементы списков, 2 - страничка
  // Page - # страницы
  // ItemList - # списка (0 - LT, 1 - LB, 2 - RT, 3 - RB)
  // Item - # элемента списка (для кнопок: 0 - OK, 1 - Save,
  //                           2 - Restore, 3 - Multiplayer)
  // Реагирование на возвращаемые значения:
  // 0 - ничего, 1 - перерисовка, 2 - закрытие диалога

  int *ButtonsStates;         // указатель на массив состояний кнопок
                              // -1 - нет кнопки, 0 - кнопка неактивна, 1 - активна
                              // #0 - кнопка Ok,  (-1 не действует)
                              // #1 - Save,
                              // #2 - Restore,
                              // #3 - Multiplayer,
                              // #4 - UnSelectAll,
                              // #5 - SelectAll,
                              // #6 - Next,
                              // #7 - Back,
                              // #8 - Load,
                              // #9 - Restore Multiplayer
  char* NextButtonHint;       // хинт для кнопки Next
  char* BackButtonHint;       // хинт для кнопки Back
//  char ShowIntro;            // показывать/нет интро};
  Dword Flags;
                              // 0x00000001 - показать/нет интро
                              // 0x00000002 - разрешено изменение/нет
};

//=================================================
struct _ChooseFile {
  char *Caption;        // Заголовок диалога
  char *Description;    // Пояснение к Диалогу
  char *Directory;      // каталог для выбора
  char *Mask;           // маска файлов (можно использовать комбинации типа "*.cpp|*.h")
  char *Buf;            // буфер куда копировать полный путь к выбранному файлу
  int   Buflen;           // размер буфера вывода
  int   Attributes;       // атрибуты файлов (можно использовать комбинации типа "$00000001 | $00000002")
  /*
                          $00000001	Read-only files
                          $00000002	Hidden files
                          $00000004	System files
                          $00000008	Volume ID files
                          $00000010	Directory files
                          $00000020	Archive files
                          $0000003F	Any file
  */
  int   ShowCancel;      // показывать кнопку Cancel
  int   FileEditEnabled; // можно ли руками вводить имя файла
  int   Flags;            // резерв
  };
//================================================= // Dialogue12
struct _IconListItem {
 char *Description;     // описание
 char *Path;            // путь до картинки
 int Checked;           // состояние: выбрано/невыбрано
};
//=================================================
struct _IconList {
 char *Caption;         // заголовок диалога
 _IconListItem *Items;  // список иконок
 int ItemCount;         // количество элементов в списке
 int OnlyOne;           // можно выбирать только 1 элемент или нет
 int ShowCancel;        // показывать кнопку Cancel
 int Flag1;             // ррезерв
};
//=================================================
struct _MonsterInfo{
  char  *Caption;         // заголовок диалога
  // Информация
  char  *Info;            // информация о твари
  char  *Picture;         // изображение твари
  char  *PictureHint;     // хинт к изображению твари
  char  **TxtProperties;  // [6] текстовые доп. свойства
  char  **IcoProperties;  // [6] иконки доп. свойств, "NONE" - для отображения заглушки
  char  **HintProperties; // [6] подсказки к  доп. свойствам
  char  *ColCaptions;     // заголовки столбцов - одна строка, по 7 символов на столбец (11*7)
  char  *ColHint;         // заголовки столбцов - подсказки
  char  **RowCaptions;    // [16] заголовки строк
  char  **RowCaptionHints;// [16] заголовки строк, подсказки
  char  **Rows;           // [16] значения ячеек таблицы - 16 строк по 7 символов на столбец (11*7)
  char  **RowHints;       // [16] подсказки к строкам
  int IcoPropertiesCount; // [0 - 6] количество иконок доп. свойств
  int ShowSpecButton;     // показывать кнопку
  char *SpecButtonHint;   // подсказка к кнопке
  int CurPropColLeft;  // начало столбца с текущими координатами твари в символах
  int CurPropColRight; // конец столбца с текущими координатами твари в символах
  char *ArtIcon;         // иконка артифакта ("NONE" - пустой)
  char *ArtHint;         // хинт для иконки артифакта
  int ArtOutput;         // артифакт отдается - 1, оставляется - 0
  int Flags;             // флаги - см. ниже
                         // Flags & 0x00000001 - можно передавать артефакт
  int ArtCopy;           // значения:
                         // 0,... - значения
                         // <0 - скрыть
  // вызов ф-ции
  int (*SpecButtonPush)();// указатель на ф-цию нажатия кнопки.
                          // Возвр. значения: 0 - ничего
                          //                  1 - закрыть вызвавший диалог
  int (*OnControlClick)(int ContorIndex,int MouseButton,int ShiftState); // указатель на ф-цию клика по коннтролу
                          // ContorIndex:     0 - портрет (c AVI не работает)
                          //                  1 - таблица (содержимое, заголовки столбцов, заголовки строк)
                          //                  2 - дополнительные свойства 1 (иконка и текст)
                          //                  3 - дополнительные свойства 2 (иконка и текст)
                          //                  4 - дополнительные свойства 3 (иконка и текст)
                          //                  5 - дополнительные свойства 4 (иконка и текст)
                          //                  6 - дополнительные свойства 5 (иконка и текст)
                          //                  7 - дополнительные свойства 6 (иконка и текст)
                          //                  12 - дополнительные свойства 7 (иконка и текст)
                          //                  13 - дополнительные свойства 8 (иконка и текст)
                          //                  8 - поле информации о твари
                          //                  9 - заголовок диалога
                          //                  10 - кнопка №2 (справа от кнопки "Закрыть") [левый клик не работает]
                          //                  11 - иконка атрефакта [левый клик не работает]
                          // MouseButton:     0 - левая кнопка мыши
                          //                  1 - правая кнопка мыши
                          //                  2 - средняя кнопка мыши
                          // ShiftState:
                          // 0x0000001      ssShift	The Shift key is held down.
                          // 0x0000002      ssAlt	The Alt key is held down.
                          // 0x0000004      ssCtrl	The Ctrl key is held down.
                          // 0x0000008      ssLeft	The left mouse button is held down.
                          // 0x0000010      ssRight	The right mouse button is held down.
                          // 0x0000020      ssMiddle	The middle mouse button is held down.
                          // 0x0000040      ssDouble	The mouse was double-clicked.
                          // Возвр. значения: 0 - ничего
                          //                  1 - закрыть вызвавший диалог
};

