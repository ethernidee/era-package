ZVSE2
; ========== EVENTS ==========
!?FU(OnAfterErmInstructions);
!!SN:W^era_everyDayTimerLastDay^/-1;

; Extended OnEveryDay trigger. The following global variables are automatically set:
; - i^timerDay^:        1..+inf
; - i^timerWeekDay^:    1..7
; - i^timerMonthDay^:   1..28
; - i^timerWeek^:       1..+inf
; - i^timerMonthWeek^:  1..4
; - i^timerMonth^:      1..+inf
; - i^timerOnce^:       0..1
; - i^timerOwner^:      0..7
; - i^timerIsAi^:       0..1
; - i^timerIsHuman^:    0..1
!?FU(OnEveryDay);
!#VA(day:x) (weekDay:x) (once:x) (owner:x) (isAi:x);

!!OW:C?(owner) I(owner)/?(isAi);
!!VR(day):Sc;
!!VR(weekDay):S(day) -1 %7 +1;

!!VR(lastTimerDay:y):Si^era_everyDayTimerLastDay^;
!!VRi^era_everyDayTimerLastDay^:S(day);
!!VR(once):S(FALSE);
!!VR(once)&(lastTimerDay)<>(day):S(TRUE);

!!VRi^timerDay^:S(day);
!!VRi^timerWeekDay^:S(weekDay);
!!VRi^timerMonthDay^:S(day) -1 %(DAYS_IN_MONTH) +1;
!!VRi^timerWeek^:S(day) -1 :(DAYS_IN_WEEK) +1;
!!VRi^timerMonthWeek^:S(day) -1 %(DAYS_IN_MONTH) :(DAYS_IN_WEEK) +1;
!!VRi^timerMonth^:S(day) -1 :(DAYS_IN_MONTH) +1;
!!VRi^timerOnce^:S(once);
!!VRi^timerOwner^:S(owner);
!!VRi^timerIsAi^:S(isAi);
!!VRi^timerIsHuman^:S(TRUE) -(isAi);

!?FU(OnBeforeBattle);
!!VRi^battle_round^:S(INT_MIN);
!!FU(UpdateBattleVars):P;

!?FU(OnBeforeBattleUniversal);
!!VRi^battle_round^:S(INT_MIN);
!!VRi^battle_current_side^:S(BATTLE_LEFT);
!!VRi^battle_current_stack^:S(NO_STACK);
!!VRi^battle_acting_stack^:S(NO_STACK);
!!VRi^battle_acting_side^:S(BATTLE_LEFT);
!!FU(UpdateBattleVars):P;

!?FU(OnBattleRound);
!!VRi^battle_round^:Sv997;

!?FU(OnBeforeBattleStackTurn);
!#VA(activeStack:x);
!!VRi^battle_current_side^:S(activeStack) :(BATTLE_STACKS_PER_SIDE);
!!VRi^battle_current_stack^:S(activeStack);

!?FU(OnBattleStackObtainsTurn);
!#VA(stackSide:x) (stackInd:x);
!!VRi^battle_current_side^:S(stackSide);
!!VRi^battle_current_stack^:S(stackSide) *(BATTLE_STACKS_PER_SIDE) +(stackInd);

!?FU(OnBeforeBattleAction);
!!BG:N?i^battle_acting_stack^;
!!VRi^battle_acting_side^:Si^battle_acting_stack^ :(BATTLE_STACKS_PER_SIDE);
; ======== END EVENTS ========


; ========== ARRAYS ==========
!?FU(NewIntArray);
; Creates and returns trigger local array of integers.
; Alternative function arguments:
;  (?result)                     The result array will have 0 items.
;  (size)/(?result)              The result array will have (size) items with 0 value.
;  (size)/(fillValue)/(?result)  The result array will have (size) items will (fillValue) value
;  You may optionally specify (storageType) parameter after (?result) argument with value like M_STORED or M_TEMP.
!#VA(arg1:x);
!#VA(arg2:x);
!#VA(arg3:x);

!!FU:A?(numArgs:y);
!!VR(storageType:y):S(M_TRIGGER_LOCAL);

!!if&(numArgs)>=2:;
  !!VR(penultimateArgInd:y):S(numArgs) -1;
  !!FU:S(penultimateArgInd)/?(penultimateArgSyntax:y);

  !!if&(penultimateArgSyntax)=(ARG_SYNTAX_GET):;
    !!VR(storageType):Sx(numArgs);
    !!VR(numArgs):-1;
  !!en;
!!en;

!!if&(numArgs)<=1:;
  !!SN:M(M_AUTO_ID)/0/(M_INT)/(storageType)/?(arg1:x) F^ExtendArrayLifetime^/(arg1);
!!el&(numArgs)<=2:;
  !!SN:M(M_AUTO_ID)/(arg1)/(M_INT)/(storageType)/?(arg2:x) F^ExtendArrayLifetime^/(arg2);
!!el&(numArgs)<=3:;
  !!SN:M(M_AUTO_ID)/(arg1)/(M_INT)/(storageType)/?(arg3:x) F^ExtendArrayLifetime^/(arg3);
  !!FU(Array_Fill):P(arg3)/(arg2)/0;
!!en;

!?FU(NewStrArray);
; Creates and returns trigger local array of strings.
; Alternative function arguments:
;  (?result)                     The result array will have 0 items.
;  (size)/(?result)              The result array will have (size) items with ^^ value.
;  (size)/(fillValue)/(?result)  The result array will have (size) items will (fillValue) value
;  You may optionally specify (storageType) parameter after (?result) argument with value like M_STORED or M_TEMP.
!#VA(arg1:x);
!#VA(arg2:x);
!#VA(arg3:x);

!!FU:A?(numArgs:y);
!!VR(storageType:y):S(M_TRIGGER_LOCAL);

!!if&(numArgs)>=2:;
  !!VR(penultimateArgInd:y):S(numArgs) -1;
  !!FU:S(penultimateArgInd)/?(penultimateArgSyntax:y);

  !!if&(penultimateArgSyntax)=(ARG_SYNTAX_GET):;
    !!VR(storageType):Sx(numArgs);
    !!VR(numArgs):-1;
  !!en;
!!en;

!!if&(numArgs)<=1:;
  !!SN:M(M_AUTO_ID)/0/(M_STR)/(storageType)/?(arg1:x) F^ExtendArrayLifetime^/(arg1);
!!el&(numArgs)<=2:;
  !!SN:M(M_AUTO_ID)/(arg1)/(M_STR)/(storageType)/?(arg2:x) F^ExtendArrayLifetime^/(arg2);
!!el&(numArgs)<=3:;
  !!SN:M(M_AUTO_ID)/(arg1)/(M_STR)/(storageType)/?(arg3:x) F^ExtendArrayLifetime^/(arg3);
  
  !!re i/0/(arg1)/1/-1:;
    !!SN:V(arg3)/i/z(arg2);
  !!en:;
!!en;

!?FU(Array_Push);
; Adds new items to the end of the array, resizing it automatically.
!#VA(list:x);      ID of array to push items to
!#VA(firstItem:x); ... Up to 15 arguments to append to list

!!VR(listSize:y):S-1;
!!SN:M(list)/?(listSize)/?(itemsType:y)/d;
!!FU&(listSize)<0:E;

!!FU:A?(numArgs:y);
!!FU&(numArgs)<=(@list):E;

!!VR(newListSize:y):S(listSize) +(numArgs) -1;
!!SN:M(list)/(newListSize);

!!re i/(listSize)/(newListSize)/1/-1:;
  !!VR(arg:y):Si -(listSize) +(@firstItem) Sx(arg);

  !!if&(itemsType)=(M_INT):;
    !!SN:V(list)/i/(arg);
  !!el:;
    !!SN:V(list)/i/z(arg);
  !!en;  
!!en:;

!?FU(Array_Pop);
; Removes items from the end of the array one by one, returning their values and resizing array automatically.
; At least single item is removed from the array, if possible.
; Example: P{list}/?{lastItem}/?{beforeLastItem}.
!#VA(list:x);      ID of array to pop items from.
!#VA(firstItem:x); OUT parameters... Up to 15 arguments to pop from the list. If item cannot be popped, it will be assigned zero value or empty string.

!!VR(listSize:y):S-1;
!!SN:M(list)/?(listSize)/?(itemsType:y)/d;
!!FU&(listSize)<0:E;

!!FU:A?(numArgs:y);
!!VR(emptyStr:z):S^^;

!!VR(numPops:y):S(numArgs) -(@firstItem) +1;
!!VR(numPops)&(numPops)<1:S1;

!!VR(newListSize:y):S(listSize) -(numPops);
!!VR(newListSize)&(newListSize)<0:S0;
!!VR(numRealPops:y):S(listSize) -(newListSize);

!!re i/0/(numPops)/1/-1:;
  !!VR(argInd:y):S(@firstItem) +i;

  !!if&i<(numRealPops):;
    !!VR(listInd:y):S-1 -i;

    !!if&(itemsType)=(M_INT):;
      !!SN:V(list)/(listInd)/?x(argInd);
    !!el:;
      !!SN:V(list)/(listInd)/?s^temp^;
      !!VRx(argInd):Zs^temp^;
    !!en;
  !!el:;
    !!if&(itemsType)=(M_INT):;
      !!VRx(argInd):S0;
    !!el:;
      !!VRx(argInd):S(@emptyStr);
    !!en;
  !!en; el
!!en:; re

!!SN:M(list)/(newListSize);
!!VRs^temp^:S^^;

!?FU(Array_Copy);
; Resizes destination array to match source array size and copies all source items into destination array.
; Both arrays must have the same items type.
!#VA(srcArray:x); ID of array to copy items from (source).
!#VA(dstArray:x); ID of array to copy items to (destination).

!!VR(numSrcItems:y):S-1;
!!SN:M(srcArray)/?(numSrcItems)/?(srcItemsType:y)/d;
!!FU&(numSrcItems)<0:E;

!!VR(numDstItems:y):S-1;
!!SN:M(dstArray)/?(numDstItems)/?(dstItemsType:y)/d;
!!FU&(numDstItems)<0:E;

!!if&(srcItemsType)<>(dstItemsType):;
  !!SN:F^ShowErmError^/^Array_Copy: cannot copy items between arrays of different types^;
  !!FU:E;
!!en;

!!SN:M(dstArray)/(numSrcItems);
!!FU&(numSrcItems)<=0:E;

!!if&(srcItemsType)=(M_INT):;
  !!SN:M(srcArray)/?(srcArrayAddr:y)/0 M(dstArray)/?(dstArrayAddr:y)/0;
  !!VR(numBytesToCopy:y):S(numSrcItems) *(SIZEOF_INT);
  !!SN:K(numBytesToCopy)/(srcArrayAddr)/(dstArrayAddr)/1;
!!el:;
  !!re i/0/(numSrcItems)/1/-1:;
    !!SN:M(srcArray)/?(strAddr:y)/i M(dstArray)/i/(strAddr);
  !!en:;
!!en;

!?FU(Array_Clone);
; Creates trigger local copy of array.
!#VA(srcArray:x); ID of array to clone.
!#VA(result:x);   ID of result trigger local array.

!!VR(numSrcItems:y):S-1;
!!SN:M(srcArray)/?(numSrcItems)/?(srcItemsType:y)/d;
!!FU&(numSrcItems)<0:E;

!!SN:M(M_AUTO_ID)/0/(srcItemsType)/(M_TRIGGER_LOCAL)/?(result) F^ExtendArrayLifetime^/(result);
!!FU(Array_Copy):P(srcArray)/(result);

!?FU(Array_Join);
; Concatenates array items into single string, using passed glue string. Works with both numeric and string arrays.
; Example: ['one', 'two', 'three'] with glue ' --- ' become 'one --- two --- three'.
!#VA(list:x);      Array ID.
!#VA(resultPtr:x); OUT. Result string
!#VA(gluePtr:x);   Optional. Glue string. Default: ''.

!!VRs^result^:S^^;
!!VR(emptyStr:z):S^^;

!!VR(numItems:y):S-1;
!!SN:M(list)/?(numItems)/?(itemsType:y)/d;
!!FU&(numItems)<0:E;

!!VR(gluePtr)&(gluePtr)=0:S(@emptyStr);

!!VR(lastItemInd:y):S(numItems) -1;

!!if&(itemsType)=(M_INT):;
  !!re i/0/(numItems)/1/-1:;
    !!SN:V(list)/i/?(item:y);
    !!VRs^result^:+^%(item)^;
    !!VRs^result^&i<(lastItemInd):+z(gluePtr);
  !!en:;
!!el:;
  !!re i/0/(numItems)/1/-1:;
    !!SN:V(list)/i/?s^temp^;
    !!VRs^result^:+s^temp^;
    !!VRs^result^&i<(lastItemInd):+z(gluePtr);
  !!en:;

  !!VRs^temp^:S^^;
!!en;

!!VR(resultPtr):Zs^result^;
!!VRs^result^:S^^;

!?FU(Array_Sort);
; Sorts array items in ascending order. Allows to sort specific array subrange.
!#VA(list:x);     Array ID.
!#VA(startInd:x); Optional. Start index of array subrange to sort. Default: 0.
!#VA(endInd:x);   Optional. End index of array subrange to sort. Default: numItems - 1.

; Get num items, exit for invalid array
!!VR(numItems:y):S0;
!!SN:M(list)/?(numItems)/?(itemsType:y)/d/?(listAddr:y);
!!FU&(numItems)<=0:E;

; Handle optional parameters
!!FU:A?(numArgs:y);
!!VR(startInd)&(numArgs)<(@startInd):S0;
!!VR(endInd)  &(numArgs)<(@endInd):S(numItems) -1;

; Normalize range to process
!!VR(startInd)&(startInd)<0:S0;
!!VR(endInd)&(endInd)>=(numItems):S(numItems) -1;
!!FU&(startInd)>=(endInd):E;

; Perform sorting
!!VR(savedV1:y):Sv1;

!!if&(itemsType)=(M_STR):;
  !!SN:F^Erm_SortStrArray^/(listAddr)/(startInd)/(endInd);
!!el:;
  !!SN:F^Erm_SortInt32Array^/(listAddr)/(startInd)/(endInd);
!!en;

!!VRv1:S(savedV1);

!?FU(CompareStrings_Bridge_INTERNAL);
!#VA(str1Addr:x) (str2Addr:x) (bridgeState:x) (result:x);

!!if&(str1Addr)<>0:;
  !!SN:X?t X(str1Addr) X?s^temp^ Xt;
  !!VR(value1:y):Zs^temp^;
  !!VRs^temp^:S^^;
!!el:;
  !!VR(value1:y):Z^^;
!!en;

!!if&(str2Addr)<>0:;
  !!SN:X?t X(str2Addr) X?s^temp^ Xt;
  !!VR(value2:y):Zs^temp^;
  !!VRs^temp^:S^^;
!!el:;
  !!VR(value2:y):Z^^;
!!en;

!!SN:V(bridgeState)/0/?(compareFunc:y)/?(compareFuncState:y);
!!FU(compareFunc):P(value1)/(value2)/(compareFuncState)/?(result);

!?FU(Array_CustomSort);
; Sorts array items in ascending order user custom comparator function. Allows to sort specific array subrange.
; It's possible to perform any complex sorting in any direction and by unlimited number of criteria, using this method.
; It's a stable sorting method, i.e. items, which we be reported as equal, will retain their relative position to each other.
; For example, if sorting 'Ann', 'David' and 'Ken' by name length, the result will be 'Ann', 'Ken', 'David' and not 'Ken', 'Ann', 'David'.
; When sorting string array, comparator function will receive z-indexes of strings as arguments.
!#VA(list:x);        Array ID.

!#VA(compareFunc:x); Comparison ERM function ID. It will be called multiple times with the following arguments:
                   ; (value1, value2, state), where 'state' is any custom value, you specify on call to Array_CustomSort.
                   ; Usually state is some array ID or external structure address, that client use to compare items.
                   ;
                   ; The function must return value:
                   ; < 0 if value1-item should be placed before value2-item
                   ; > 0 if value1-item should be placed after value2-item
                   ; 0 if the ordering between two items should be left as is.

!#VA(state:x);    Optional. Custom value to be always passed to comparison function as the third argument. Default: 0.
!#VA(startInd:x); Optional. Start index of array subrange to sort. Default: 0.
!#VA(endInd:x);   Optional. End index of array subrange to sort. Default: numItems - 1.

; Get num items, exit for invalid array
!!VR(numItems:y):S0;
!!SN:M(list)/?(numItems)/?(itemsType:y)/d/?(listAddr:y);
!!FU&(numItems)<=0:E;

; Check compare function
!!if&(compareFunc)<0:;
  !!SN:F^ShowErmError^/^Invalid comparison custom function for Array_CustomSort: %(compareFunc)^;
  !!FU:E;
!!en;

; Handle optional parameters
!!FU:A?(numArgs:y);
!!VR(startInd)&(numArgs)<(@startInd):S0;
!!VR(endInd)  &(numArgs)<(@endInd):S(numItems) -1;

; Normalize range to process
!!VR(startInd)&(startInd)<0:S0;
!!VR(endInd)&(endInd)>=(numItems):S(numItems) -1;
!!FU&(startInd)>=(endInd):E;

; Perform sorting
!!VR(savedV1:y):Sv1;

!!if&(itemsType)=(M_STR):;
  !!SN:M(M_AUTO_ID)/2/(M_INT)/(M_TRIGGER_LOCAL)/?(bridgeState:y);
  !!SN:V(bridgeState)/0/(compareFunc)/(state);
  !!SN:F^Erm_CustomStableSortInt32Array^/(listAddr)/(startInd)/(endInd)/(CompareStrings_Bridge_INTERNAL)/(bridgeState);
!!el:;
  !!SN:F^Erm_CustomStableSortInt32Array^/(listAddr)/(startInd)/(endInd)/(compareFunc)/(state);
!!en;

!!VRv1:S(savedV1);

!?FU(Array_SortedUnique);
; Leaves only unique sorted integer items in the array.
; Calling on [15, 4, 3, 3, 1, 20, 15] list will rearrange and truncate list to the following:
; [1, 3, 4, 15, 20]
!#VA(list:x); Array ID

!!SN:M(list)/?(listSize:y)/?(itemsType:y)/d;
!!FU&(listSize)<=1:E;

!!if&(itemsType)<>(M_INT):;
  !!SN:F^ShowErmError^/^Array_SortedUnique function supports only integer arrays^;
  !!FU:E;
!!en;

!!FU(Array_Sort):P(list);
!!SN:V(list)/0/?(prevItem:y);

; Find first non-unique item
!!re i/1/(listSize)/1/-1:;
  !!SN:V(list)/i/?(item:y);
  !!br&(item)=(prevItem):;
  !!VR(prevItem):S(item);
!!en:;

; Non-unique item was found
!!if&i<(listSize):;
  ; Loop though rest items, copying only unique to the left part
  !!VRj:Si +1;

  !!re j/j/(listSize)/1/-1:;
    !!SN:V(list)/j/?(item:y);

    !!if&(item)<>(prevItem):;
      !!SN:V(list)/i/(item);
      !!VRi:+1;
    !!en;

    !!VR(prevItem):S(item);
  !!en:;

  ; Truncate non-unique items
  !!SN:M(list)/i;
!!en;

!?FU(Array_Revert);
; Reverts order of itmes in the array. Allows to reverse the order of specific array subrange only.
!#VA(list:x);     Array ID.
!#VA(startInd:x); Optional. Start index of array subrange. Default: 0.
!#VA(endInd:x);   Optional. End index of array subrange. Default: numItems - 1.

; Get num items, exit for invalid array
!!VR(numItems:y):S0;
!!SN:M(list)/?(numItems)/d/d/?(listAddr:y);
!!FU&(numItems)<=0:E;

; Handle optional parameters
!!FU:A?(numArgs:y);
!!VR(startInd)&(numArgs)<(@startInd):S0;
!!VR(endInd)  &(numArgs)<(@endInd):S(numItems) -1;

; Normalize range to process
!!VR(startInd)&(startInd)<0:S0;
!!VR(endInd)&(endInd)>=(numItems):S(numItems) -1;
!!FU&(startInd)>=(endInd):E;

; Perform reversing
!!VR(savedV1:y):Sv1;
!!SN:F^Erm_RevertInt32Array^/(listAddr)/(startInd)/(endInd);
!!VRv1:S(savedV1);

!?FU(Array_Fill);
; Fills array or arrays subrange with incrementing/decrementing values.
; Example: FU(Array_Fill):P(array)/100/2; Will fill items with 100, 102, 104, 106...
!#VA(list:x);       Array ID.
!#VA(startValue:x); Starting value to fill with.
!#VA(step:x);       Value to add to increase filler on each step. Default: 0.
!#VA(startInd:x);   Optional. Start index of array subrange. Default: 0.
!#VA(endInd:x);     Optional. End index of array subrange. Default: numItems - 1.

; Get num items, exit for invalid array
!!VR(numItems:y):S0;
!!SN:M(list)/?(numItems)/d/d/?(listAddr:y);
!!FU&(numItems)<=0:E;

; Handle optional parameters
!!FU:A?(numArgs:y);
!!VR(startInd)&(numArgs)<(@startInd):S0;
!!VR(endInd)  &(numArgs)<(@endInd):S(numItems) -1;

; Normalize range to process
!!VR(startInd)&(startInd)<0:S0;
!!VR(endInd)&(endInd)>=(numItems):S(numItems) -1;
!!FU&(startInd)>(endInd):E;

; Perform filling
!!VR(savedV1:y):Sv1;
!!SN:F^Erm_FillInt32Array^/(listAddr)/(startInd)/(endInd)/(startValue)/(step);
!!VRv1:S(savedV1);

!?FU(Array_Resize);
; Changes array size, optionally filling new items with default value.
!#VA(list:x);      Array ID.
!#VA(newSize:x);   New array size.
!#VA(fillValue:x); Optional. Fill value for new items. Default: ^^ or 0.

; Get num items, exit for invalid array
!!VR(numItems:y):S-1;
!!SN:M(list)/?(numItems)/?(itemsType:y)/d;
!!FU&(numItems)<0:E;

; Perform resizing
!!SN:M(list)/(newSize);
!!FU&(newSize)<=(numItems):E;

; Exit if no fill value is set
!!FU&(fillValue)=0:E;
!!FU&(itemsType)=(M_STR)/z(fillValue)=^^:E;

; Fill new items value
!!if&(itemsType)=(M_INT):;
  !!re i/(numItems)/(newSize)/1/-1:;
    !!SN:V(list)/i/(fillValue);
  !!en:;
!!el:;
  !!re i/(numItems)/(newSize)/1/-1:;
    !!SN:V(list)/i/z(fillValue);
  !!en:;
!!en;

!?FU(Array_EnsureMinSize);
; Checks, if array has at least specified minimal size and increasing the size if not, filling new items
; with optional default value.
!#VA(list:x);      Array ID.
!#VA(minSize:x);   Minimal desired array size.
!#VA(fillValue:x); Optional. Fill value for new items. Default: ^^ or 0.

!!VR(numItems:y):S-1;
!!SN:M(list)/?(numItems);
!!FU|(numItems)<0/(numItems)>=(minSize):E;

!!FU(Array_Resize):P(list)/(minSize)/(fillValue);
; ======== END ARRAYS ========


; ========== MATH ==========

!?FU(Pow);
; Raises value to specified power. All arguments and result are floats.
!#VA(base:x) (power:x) (result:x);

!!SN:F^.Erm_Pow^/(base)/(power);
!!VR(result):Ce1;

!?FU(Sqrt);
; Returns value square root. All arguments and result are floats.
!#VA(value:x) (result:x);

!!SN:F^.Erm_Sqrt^/(value);
!!VR(result):Ce1;

!?FU(IntLog2);
; Returns Ceil(Log2(N)) or 0 for invalid values (<= 0).
!#VA(value:x) (result:x);

!!if&(value)<=0:;
  !!VR(result):S0;
  !!FU:E;
!!en;

!!VR(savedV1:y):Sv1;
!!SN:F^Erm_IntLog2^/(value);
!!VR(result):Sv1;
!!VRv1:S(savedV1);

!?FU(ConstructBitMask);
; Accepts up to 15 bit/flag positions (0..31). Returns mask with corresponding bit flags set.
; Actually, given Xi arguments, returns Sum(2 ^ xi).
; For example, P0/3/7/?(mask:y) will give 2 ^ 0 + 2 ^ 3 + 2 ^ 7 = 1 + 8 + 128 = 137.
!#VA(args:x);   ... Up to 15 bit/flag positions.
!#VA(result:x); The last argument will contain the result mask.

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@result):;
  !!SN:F^ShowErmError^/^ConstructBitMask function expects at least 2 arguments. Given %(numArgs) arguments^;
  !!FU:E;
!!en;

!!VR(mask:y):S0;

!!re i/(@args)/(numArgs)/1/-1:;
  !!VR(arg:y):Sxi;

  !!if&(arg)>=0/(arg)<=31:;
    !!VR(bit:y):S1 Sd<<(arg);
    !!VR(mask):|(bit);
  !!el:;
    !!SN:F^ShowErmError^/^Invalid bit/flag position: %(arg). Arg #%i. Expected value 0..31^;
    !!FU:E;
  !!en;
!!en:;

!!VRxi:S(mask);

!?FU(DeconstructBitMask);
; Deconstructs bit mask into list of bit/flag positions (each with 0..31 value).
; For example, P137/(list) will fill the list with [0, 3, 7] values, because
; 2 ^ 0 + 2 ^ 3 + 2 ^ 7 = 1 + 8 + 128 = 137. It means, that bits 0, 3 and 7 are set.
!#VA(mask:x);   Bit mask.
!#VA(result:x); Will contain new trigger local array ID with bit/flag positions.

!!SN:M(M_AUTO_ID)/0/(M_INT)/(M_TRIGGER_LOCAL)/?(result) F^ExtendArrayLifetime^/(result);

!!VR(bit:y):S1;

!!re i/0/31:;
  !!VR(test:y):S(mask) &(bit);
  !!SN&(test)<>0:M(result)/d1 V(result)/-1/i;
  !!VR(bit):Sd<<1;
!!en:;

!?FU(Tm32Encode);
; Fast and reversable int32 hashing. Link: https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key
!#VA(value:x) (result:x);

!!VRf:S(value) Sd>>16 X(value) *73244475;
!!VRg:Sf Sd>>16 Xf *73244475;
!!VR(result):Sg Sd>>16 Xg;

!?FU(Tm32Decode);
; Fast and reversable int32 hashing. Link: https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key
!#VA(value:x) (result:x);

!!VRf:S(value) Sd>>16 X(value) *295559667;
!!VRg:Sf Sd>>16 Xf *295559667;
!!VR(result):Sg Sd>>16 Xg;
; ======== END MATH ========


; ================ STRINGS ================
!?FU(GetStrAtAddr);
; Reads null terminated string at specified address into s^result^ variable.
; Null address (0) results in empty string.
!#VA(strAddr:x);   Address of null-terminated string in memory or 0.
!#VA(resultPtr:x); String variable, to copy string contents to.

!!SN:X?t X(strAddr) X?s^temp^ Xt;
!!VR(resultPtr):Zs^temp^;
!!VRs^temp^:S^^;

!?FU(CompareStrings);
; Compares two strings. Returns value <0, =0 or >0, corresponding to items relation.
!#VA(str1Ptr:x) (str2Ptr:x) (result:x);

!!VR(result):S0;

!!if&z(str1Ptr)<z(str2Ptr):;
  !!VR(result):S-1;
!!el&z(str1Ptr)>z(str2Ptr):;
  !!VR(result):S1;
!!en;

!?FU(StrToUpper);
; Converts given string to upper case.
!#VA(strPtr:x);    Source string.
!#VA(resultPtr:x); OUT. Result string.

!!SN:M(M_AUTO_ID)/1/(M_STR)/(M_TRIGGER_LOCAL)/?(buf:y) M(buf)/0/z(strPtr) M(buf)/?(strAddr:y)/0;

!!VR(savedV1:y):Sv1;
!!SN:F^CharUpperA^/(strAddr);
!!VRv1:S(savedV1);

!!SN:M(buf)/0/?s^temp^;
!!VR(resultPtr):Zs^temp^;
!!VRs^temp^:S^^;

!?FU(StrToLower);
; Converts given string to lower case.
!#VA(strPtr:x);    Source string.
!#VA(resultPtr:x); OUT. Result string.

!!SN:M(M_AUTO_ID)/1/(M_STR)/(M_TRIGGER_LOCAL)/?(buf:y) M(buf)/0/z(strPtr) M(buf)/?(strAddr:y)/0;

!!VR(savedV1:y):Sv1;
!!SN:F^CharLowerA^/(strAddr);
!!VRv1:S(savedV1);

!!SN:M(buf)/0/?s^temp^;
!!VR(resultPtr):Zs^temp^;
!!VRs^temp^:S^^;

!?FU(DecorateInt);
; Converts integer to string, separating each three digit group by "era.locale.thousand_separator" characer.
; Example: P74276689 => "74 276 689"
!#VA(value:x);              Number to decorate.
!#VA(resultPtr:x);          OUT. Result string.
!#VA(ignoreSmallNumbers:x); Optional boolean. If set to DONT_DECORATE_SMALL_INTS, values <= 9999 are not decorated. Default: false.

!!VR(savedV1:y):Sv1;
!!SN:F^DecorateInt^/(value)/?(text:z)/(ignoreSmallNumbers);
!!VR(resultPtr):S(@text);
!!VRv1:S(savedV1);

!?FU(FormatQuantity);
; Formats given positive or negative quantity to human-readable string with desired constraints on length and maximal number of digits.
; Uses game locale settings and metric suffixes like "K", "M" and "G".
; Example: P-1234567890/6/4 => "-1.23G"
!#VA(value:x);     Quantity to format.
!#VA(resultPtr:x); OUT. Result string.
!#VA(maxLen:x);    Optional. Maximum desired string length in logical characters. Default: 5.
!#VA(maxDigits:x); Optional. Maximum number of digits to use in result (the more digits to display, the slower the number is read by humans). Default: 4.

!!FU:A?(numArgs:y);
!!VR(maxLen)&(numArgs)<(@maxLen):S5;
!!VR(maxDigits)&(numArgs)<(@maxDigits):S4;

!!VR(savedV1:y):Sv1;
!!SN:F^FormatQuantity^/(value)/?(text:z)/(SIZEOF_ZSTR)/(maxLen)/(maxDigits);
!!VR(resultPtr):S(@text);
!!VRv1:S(savedV1);
; ============== END STRINGS ==============


; ============== ERROR HANDLING ==============
!?FU(DisableErrors);
; Disables ERM error messages and resets error option.
!!UN:P(WOG_OPT_MUTE_ERRORS)/(TRUE) P(WOG_OPT_LAST_ERROR)/(FALSE);

!?FU(EnableErrors);
; Enables ERM error messages and returns last error flag (TRUE or FALSE).
!#VA(result:x);
!!UN:P(WOG_OPT_MUTE_ERRORS)/(TRUE) P(WOG_OPT_LAST_ERROR)/?(result);
; ============ END ERROR HANDLING ============


; =============== DIALOGS ===============
!?FU(H3Dlg_StopAnimation);
; Stops current dialogs animation
!!SN:E5864096/1;

!?FU(H3Dlg_ResumeAnimation);
; Resumes stopped dialogs animation
!!SN:E5864272/1;

!?FU(H3Dlg_ShowPopup);
; Shows H3 dialog as RMB popup.
!#VA(h3Dlg:x); H3 dialog object address
!!FU(H3Dlg_StopAnimation):P;
!!SN:E6245264/2/(h3Dlg);
!!FU(H3Dlg_ResumeAnimation):P;

!?FU(H3Dlg_Coords);
; Allows to access H3 dialog display coordinates. Automatically fixed invalid coordinates.
!#VA(h3Dlg:x); H3 dialog object address.
!#VA(x:x);     X-coordinate, supports GET/SET/ADD syntax
!#VA(y:x);     Y-coordinate, supports GET/SET/ADD syntax

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@y):;
  !!SN:F^ShowErmError^/^H3Dlg_Coords: invalid number of argumnets^;
  !!FU:E;
!!en;

!!if&(h3Dlg)=(NULL):;
  !!SN:F^ShowErmError^/^H3Dlg_Coords: h3Dlg is NULL^;
  !!FU:E;
!!en;

!!FU:S(@x)/?(xSyntax:y) S(@y)/?(ySyntax:y);

!!UN:C(h3Dlg)/(STRUCT_H3DLG_X)/(UNC_INT)/?(origX:y);

!!if&(xSyntax)=(ARG_SYNTAX_GET):;
  !!VR(x):S(origX);
!!el:;
  !!UN:C(h3Dlg)/(STRUCT_H3DLG_WIDTH)/(UNC_INT)/?(dlgWidth:y);
  !!UN:C(ADDR_GAME_SCREEN_WIDTH)/(UNC_INT16)/?(gameScreenWidth:y);
  !!VR(maxX:y):S(gameScreenWidth) -(dlgWidth) -(DLG_BOX_SHADOW_WIDTH);
  
  !!VR(x)&(xSyntax)=(ARG_SYNTAX_ADD):+(origX);
  !!VR(x):F0/(maxX);
  
  !!UN:C(h3Dlg)/(STRUCT_H3DLG_X)/(UNC_INT)/(x);
!!en;

!!UN:C(h3Dlg)/(STRUCT_H3DLG_Y)/(UNC_INT)/?(origY:y);

!!if&(ySyntax)=(ARG_SYNTAX_GET):;
  !!VR(y):S(origY);
!!el:;
  !!UN:C(h3Dlg)/(STRUCT_H3DLG_HEIGHT)/(UNC_INT)/?(dlgHeight:y);
  !!UN:C(ADDR_GAME_SCREEN_HEIGHT)/(UNC_INT16)/?(gameScreenHeight:y);
  !!VR(maxY:y):S(gameScreenHeight) -(dlgHeight) -(DLG_BOX_SHADOW_WIDTH);
  
  !!VR(y)&(ySyntax)=(ARG_SYNTAX_ADD):+(origY);
  !!VR(y):F0/(maxY);
  
  !!UN:C(h3Dlg)/(STRUCT_H3DLG_Y)/(UNC_INT)/(y);
!!en;

!?FU(DL_FindById);
; Returns DL dialog object address by DL id or (NULL) .
!#VA(dlgId:x);
!#VA(result:x);
!!SN:E7510739/1/(dlgId);
!!VR(result):Sv1;

!?FU(DL_Destroy);
; Destroys DL dialog object.
!#VA(dlgObj:x);
!!SN:E7518240/2/(dlgObj);

!?FU(DL_ShowPopup);
; Shows DL dialog as RMB popup.
; The dialog will be destroyed after showing. Call DL:N again to recreate it.
; © GrayFace
!#VA(dlgId:x); DL dialog ID.
!!VR(savedV1:y):Sv1;
!!FU(DL_FindById):P(dlgId)/?(dlgObj:y);

!!if&(dlgObj)<>(NULL):;
  !!UN:C(dlgObj)/(UNC_INT)/?(h3Dlg:y);
  !!FU(H3Dlg_ShowPopup):P(h3Dlg);
  !!FU(DL_Destroy):P(dlgObj);
!!en;

!!VRv1:S(savedV1);

!?FU(DL_Coords);
; Allows to access DL-dialog display coordinates. Call DL:N before trying to access coordinates.
; © igrik
!#VA(dlgId:x); DL dialog ID
!#VA(x:x);     X-coordinate, supports GET/SET/ADD syntax
!#VA(y:x);     Y-coordinate, supports GET/SET/ADD syntax

!!FU(DL_FindById):P(dlgId)/?(dlgObj:y);

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@y):;
  !!SN:F^ShowErmError^/^DL_Coords: invalid number of argumnets^;
  !!FU:E;
!!en;

!!if&(dlgObj)=(NULL):;
  !!SN:F^ShowErmError^/^DL_Coords: DL-dialog %(dlgId) is not loaded^;
  !!FU:E;
!!en;

!!UN:C(dlgObj)/(UNC_INT)/?(h3Dlg:y);
!!FU:S(@x)/?(xSyntax:y) S(@y)/?(ySyntax:y);

!!FU(H3Dlg_Coords):P(h3Dlg)/?(origX:y)/?(origY:y);

!!VR(x)&(xSyntax)=(ARG_SYNTAX_GET):S(origX);
!!VR(x)&(xSyntax)=(ARG_SYNTAX_ADD):+(origX);
!!VR(y)&(ySyntax)=(ARG_SYNTAX_GET):S(origY);
!!VR(y)&(ySyntax)=(ARG_SYNTAX_ADD):+(origY);

!!FU(H3Dlg_Coords)|(xSyntax)<>(ARG_SYNTAX_GET)/(ySyntax)<>(ARG_SYNTAX_GET):P(h3Dlg)/(x)/(y);

!?FU(DL_GetSize);
; Returns DL-dialog width and height.
!#VA(dlgId:x);  DL dialog ID
!#VA(width:x);  OUT. Dialog width
!#VA(height:x); OUT. Dialog height

!!FU(DL_FindById):P(dlgId)/?(dlgObj:y);

!!if&(dlgObj)=(NULL):;
  !!SN:F^ShowErmError^/^DL_GetSize: DL-dialog %(dlgId) is not loaded^;
  !!FU:E;
!!en;

!!UN:C(dlgObj)/(UNC_INT)/?(h3Dlg:y);
!!UN:C(h3Dlg)/(STRUCT_H3DLG_WIDTH)/(UNC_INT)/?(width);
!!UN:C(h3Dlg)/(STRUCT_H3DLG_HEIGHT)/(UNC_INT)/?(height);

!?FU(DL_AlignDlg);
; Aligns dialog display position. Call DL:N before trying to use this function.
!#VA(dlgId:x);     DL dialog ID
!#VA(alignment:x); Bit-mask of TEXT_ALIGN_XXX constants.

!!FU(DL_FindById):P(dlgId)/?(dlgObj:y);

!!if&(dlgObj)=(NULL):;
  !!SN:F^ShowErmError^/^DL_AlignDlg: DL-dialog %(dlgId) is not loaded^;
  !!FU:E;
!!en;

!!UN:C(dlgObj)/(UNC_INT)/?(h3Dlg:y);
!!UN:C(h3Dlg)/(STRUCT_H3DLG_WIDTH)/(UNC_INT)/?(dlgWidth:y);
!!UN:C(h3Dlg)/(STRUCT_H3DLG_HEIGHT)/(UNC_INT)/?(dlgHeight:y);
!!UN:C(ADDR_GAME_SCREEN_WIDTH)/(UNC_INT16)/?(gameScreenWidth:y);
!!UN:C(ADDR_GAME_SCREEN_HEIGHT)/(UNC_INT16)/?(gameScreenHeight:y);

!!VR(alignCenter:y):S(alignment) &(TEXT_ALIGN_CENTER);
!!VR(alignRight:y):S(alignment) &(TEXT_ALIGN_RIGHT);
!!VR(alignMiddle:y):S(alignment) &(TEXT_ALIGN_MIDDLE);
!!VR(alignBottom:y):S(alignment) &(TEXT_ALIGN_BOTTOM);

!!VR(x:y):S0;

!!if&(alignCenter)<>(FALSE):;
  !!VR(x):S(gameScreenWidth) -(dlgWidth) :2;
!!el&(alignRight)<>(FALSE):;
  !!VR(x):S(gameScreenWidth) -(dlgWidth);
!!en;

!!VR(y:y):S0;

!!if&(alignMiddle)<>(FALSE):;
  !!VR(y):S(gameScreenHeight) -(dlgHeight) :2;
!!el&(alignBottom)<>(FALSE):;
  !!VR(y):S(gameScreenHeight) -(dlgHeight);
!!en;

!!UN:C(h3Dlg)/(STRUCT_H3DLG_X)/(UNC_INT)/(x);
!!UN:C(h3Dlg)/(STRUCT_H3DLG_Y)/(UNC_INT)/(y);
; ============= END DIALOGS =============


; =============== BATTLE ===============
!?FU(UpdateBattleVars);
; Updates global variables with most of "OnBeforeBattle/Universal" event parameters.
; Call this function if you change anything, except monsters, via BA command.
!!BA:Q?i^battle_isQuick^ P?i^battle_x^/?i^battle_y^/?i^battle_z^;
!!BA:O?i^battle_owner_0^/?i^battle_owner_1^;
!!BA:H0/?i^battle_hero_0^ H1/?i^battle_hero_1^;

; Replace invalid defender hero values like (NO_DEFENDING_HERO) with normalized (NO_HERO)
!!VRi^battle_hero_1^&i^battle_hero_1^<(HERO_FIRST):S(NO_HERO);

!!VRi^battle_ai_0^:S(TRUE);
!!VRi^battle_ai_1^:S(TRUE);
!!VRi^battle_remote_0^:S(FALSE);
!!VRi^battle_remote_1^:S(FALSE);

!!if&i^battle_owner_0^<>(NO_OWNER):;
  !!OW:Ii^battle_owner_0^/?i^battle_ai_0^ Gi^battle_owner_0^/?(isLocalHuman:y);
  !!VRi^battle_remote_0^&i^battle_ai_0^=(FALSE)/(isLocalHuman)=(FALSE):S(TRUE);
!!en;

!!if&i^battle_owner_1^<>(NO_OWNER):;
  !!OW:Ii^battle_owner_1^/?i^battle_ai_1^ Gi^battle_owner_1^/?(isLocalHuman:y);
  !!VRi^battle_remote_1^&i^battle_ai_1^=(FALSE)/(isLocalHuman)=(FALSE):S(TRUE);
!!en;

!!VRi^battle_local_0^:S(TRUE) Xi^battle_remote_0^;
!!VRi^battle_local_1^:S(TRUE) Xi^battle_remote_1^;
!!VRi^battle_human_0^:S(TRUE) Xi^battle_ai_0^;
!!VRi^battle_human_1^:S(TRUE) Xi^battle_ai_1^;
!!VRi^battle_localHuman_0^:Si^battle_local_0^ &i^battle_human_0^;
!!VRi^battle_localHuman_1^:Si^battle_local_1^ &i^battle_human_1^;

!!VRi^battle_hasHuman^:S(FALSE);
!!VRi^battle_hasHuman^|i^battle_human_0^<>(FALSE)/i^battle_human_1^<>(FALSE):S(TRUE);

!!VRi^battle_humanOnly^:Si^battle_human_0^ &i^battle_human_1^;
!!VRi^battle_aiOnly^:Si^battle_ai_0^ &i^battle_ai_1^;
!!VRi^battle_isVisible^:Si^battle_withoutHuman^ |i^battle_isQuick^ X(TRUE);
!!VRi^battle_isNetwork^:Si^battle_remote_0^ |i^battle_remote_1^;

!!VR(battleType:y):S0;
!!VR(battleType)&i^battle_human_0^<>(FALSE):    |(BATTLE_TYPE_FLAG_LEFT_IS_HUMAN);
!!VR(battleType)&i^battle_human_1^<>(FALSE):    |(BATTLE_TYPE_FLAG_RIGHT_IS_HUMAN);
!!VR(battleType)&i^battle_owner_0^<>(NO_OWNER): |(BATTLE_TYPE_FLAG_LEFT_HAS_OWNER);
!!VR(battleType)&i^battle_owner_1^<>(NO_OWNER): |(BATTLE_TYPE_FLAG_RIGHT_HAS_OWNER);
!!VR(battleType)&i^battle_hero_0^<>(NO_HERO):   |(BATTLE_TYPE_FLAG_LEFT_HAS_HERO);
!!VR(battleType)&i^battle_hero_1^<>(NO_HERO):   |(BATTLE_TYPE_FLAG_RIGHT_HAS_HERO);
!!VRi^battle_type^:S(battleType);
; ============= END BATTLE =============


; ============== MONSTERS ==============
!?FU(MonCountToFuzzyText);
; Converts monster quantity to stringish value range like "50-99" or "2K+" with maximum length restriction.
; Example P777/?{result}/(MON_FUZZY_COUNT_SHORT) => "500-999".
!#VA(monNum:x);         Number of monsters to convert to text.
!#VA(resultPtr:x);      OUT. Result string
!#VA(maxTextLength:x);  Optional. Result length restriction in the form of MON_FUZZY_COUNT_XXX constant. Default: MON_FUZZY_COUNT_SHORT

!!if&(monNum)<0:;
  !!SN:F^ShowErmError^/^MonCountToFuzzyText: negative monster quantity %(monNum)^;
  !!FU:E;
!!en;

!!VR(h3HintsBaseAddr:y):S6970400;
!!VR(rangeInd:y):-1;

!!if&(monNum)<=4:;
  !!VRs^result^:S^1-4^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S0;
!!el&(monNum)<=9:;
  !!VRs^result^:S^5-9^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S1;
!!el&(monNum)<=19:;
  !!VRs^result^:S^10-19^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S2;
!!el&(monNum)<=49:;
  !!VRs^result^:S^20-49^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S3;
!!el&(monNum)<=99:;
  !!VRs^result^:S^50-99^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S4;
!!el&(monNum)<=249:;
  !!VRs^result^:S^100-249^;
  !!VRs^result^&(maxTextLength)=(MON_FUZZY_COUNT_EXTRA_SHORT):S^100+^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S5;
!!el&(monNum)<=499:;
  !!VRs^result^:S^250-499^;
  !!VRs^result^&(maxTextLength)=(MON_FUZZY_COUNT_EXTRA_SHORT):S^250+^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S6;
!!el&(monNum)<=999:;
  !!VRs^result^:S^500-999^;
  !!VRs^result^&(maxTextLength)=(MON_FUZZY_COUNT_EXTRA_SHORT):S^500+^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S7;
!!el&(monNum)<2000/(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):;
  !!VR(rangeInd):S8;
!!el&(monNum)<1000000:;
  !!VR(thousandInd:y):S(monNum) :1000;
  !!FU(IntLog2):P(thousandInd)/?(thousandPower:y);
  !!VR(borderValue:y):S1 Sd<<(thousandPower) *1000 -1;
  !!VR(thousandPower)&(monNum)<=(borderValue):-1;
  !!VR(rangeStart:y):S1 Sd<<(thousandPower);
  !!VRs^result^:S^%(rangeStart)K+^;
!!el:;
  !!VR(billionInd:y):S(monNum) :1000000;
  !!FU(IntLog2):P(billionInd)/?(billionPower:y);
  !!VR(borderValue:y):S1 Sd<<(billionPower) *1000000 -1;
  !!VR(borderValue)&(borderValue)<0:S(INT_MAX);
  !!VR(billionPower)&(monNum)<=(borderValue):-1;
  !!VR(rangeStart:y):S1 Sd<<(billionPower);
  !!VRs^result^:S^%(rangeStart)M+^;
!!en;

!!if&(rangeInd)<>-1:;
  !!VRf:S(rangeInd) *(SIZEOF_INT) *3 +(SIZEOF_INT) +(h3HintsBaseAddr);
  !!UN:Cf/(SIZEOF_PTR)/?(strAddr:y);
  !!FU(GetStrAtAddr):P(strAddr)/?s^result^;
!!en;

!!VR(resultPtr):Zs^result^;
!!VRs^result^:S^^;
; ============ END MONSTERS ============